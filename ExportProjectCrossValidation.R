library(RMySQL)
library(plotrix)
library(unbalanced)
library(DMwR)
library(dplyr)
library(e1071)
library(randomForest)
library(foreign)
library(VGAM)
options(java.parameters = "-Xmx16g")
library(RWeka)
library(caret)
library(vegan)
library(kknn)
library(kernlab)

path<-"/home/rique/Temp_Results_R/10-fold-validation/"
dir.create(path,recursive = TRUE)
setwd(path)

stratified <- function(df, group, size, select = NULL, 
                       replace = FALSE, bothSets = FALSE) {
  if (is.null(select)) {
    df <- df
  } else {
    if (is.null(names(select))) stop("'select' must be a named list")
    if (!all(names(select) %in% names(df)))
      stop("Please verify your 'select' argument")
    temp <- sapply(names(select),
                   function(x) df[[x]] %in% select[[x]])
    df <- df[rowSums(temp) == length(select), ]
  }
  df.interaction <- interaction(df[group], drop = TRUE)
  df.table <- table(df.interaction)
  df.split <- split(df, df.interaction)
  if (length(size) > 1) {
    if (length(size) != length(df.split))
      stop("Number of groups is ", length(df.split),
           " but number of sizes supplied is ", length(size))
    if (is.null(names(size))) {
      n <- setNames(size, names(df.split))
      message(sQuote("size"), " vector entered as:\n\nsize = structure(c(",
              paste(n, collapse = ", "), "),\n.Names = c(",
              paste(shQuote(names(n)), collapse = ", "), ")) \n\n")
    } else {
      ifelse(all(names(size) %in% names(df.split)),
             n <- size[names(df.split)],
             stop("Named vector supplied with names ",
                  paste(names(size), collapse = ", "),
                  "\n but the names for the group levels are ",
                  paste(names(df.split), collapse = ", ")))
    }
  } else if (size < 1) {
    n <- round(df.table * size, digits = 0)
  } else if (size >= 1) {
    if (all(df.table >= size) || isTRUE(replace)) {
      n <- setNames(rep(size, length.out = length(df.split)),
                    names(df.split))
    } else {
      message(
        "Some groups\n---",
        paste(names(df.table[df.table < size]), collapse = ", "),
        "---\ncontain fewer observations",
        " than desired number of samples.\n",
        "All observations have been returned from those groups.")
      n <- c(sapply(df.table[df.table >= size], function(x) x = size),
             df.table[df.table < size])
    }
  }
  temp <- lapply(
    names(df.split),
    function(x) df.split[[x]][sample(df.table[x],
                                     n[x], replace = replace), ])
  set1 <- do.call("rbind", temp)
  
  if (isTRUE(bothSets)) {
    set2 <- df[!rownames(df) %in% rownames(set1), ]
    list(SET1 = set1, SET2 = set2)
  } else {
    set1
  }
}

stratified_less <- function(dataframe, classifier){
  if(class(dataframe[,classifier])!="factor"){
    print("seu classificador nao deve ser numerico!!!")
    nrow(null)
  }
  temp <- summary(dataframe[,classifier])
  temp <- data.frame(temp)
  if(nrow(temp)!=2){
    print("seu classificador tem mais de 2 classificações!!!")
    nrow(null)
  }
  names <- row.names(temp)
  if(temp[names[1],]>temp[names[2],]){
    minority <- names[2]
    maiority <- names[1]
    dataframe_minority <- dataframe[dataframe[,classifier] == names[2],]
    dataframe <- dataframe[dataframe[,classifier] == names[1],]
  }else{
    minority <- names[1]
    maiority <- names[2]
    dataframe_minority <- dataframe[dataframe[,classifier] == names[1],]
    dataframe <- dataframe[dataframe[,classifier] == names[2],]
  }
  
  # Prepare Data
  dataframe[,classifier] <- NULL
  scale_data <- na.omit(dataframe) # listwise deletion of missing
  scale_data <- scale(dataframe) # standardize variables 
  
  n_folds <- nrow(dataframe_minority)
  
  # K-Means Cluster Analysis
  fit <- kmeans(scale_data, (n_folds)) # 5 cluster solution
  # get cluster means
  aggregate(scale_data,by=list(fit$cluster),FUN=mean)
  # append cluster assignment
  dataframe <- data.frame(dataframe, fit$cluster)
  
  dataframe <- stratified(dataframe,"fit.cluster", 1)
  
  dataframe[,"fit.cluster"] <- NULL
  dataframe[,classifier] <- maiority
  dataframe<-rbind(dataframe,dataframe_minority)
  dataframe<-dataframe[sample(nrow(dataframe)),]
  return(dataframe)
}

smote_less <- function(dataframe, classifier){
  if(class(dataframe[,classifier])!="factor"){
    print("seu classificador nao deve ser numerico!!!")
    nrow(null)
  }
  temp <- summary(dataframe[,classifier])
  temp <- data.frame(temp)
  if(nrow(temp)!=2){
    print("seu classificador tem mais de 2 classificações!!!")
    nrow(null)
  }
  names <- row.names(temp)
  if(temp[names[1],]>temp[names[2],]){
    minority <- names[2]
    maiority <- names[1]
    dataframe_minority <- dataframe[dataframe[,classifier] == names[2],]
  }else{
    minority <- names[1]
    maiority <- names[2]
    dataframe_minority <- dataframe[dataframe[,classifier] == names[1],]
  }
  
  n<-ncol(dataframe)
  output<-dataframe[,classifier]
  input<-dataframe
  input[,classifier]<-NULL
  newData<-ubBalance(X= input, Y=output, type="ubSMOTE", k=1, positive = minority, percUnder = 200, percOver = 50)
  dataframe<-cbind(newData$X,newData$Y)
  dataframe[,classifier]=dataframe[,n]
  dataframe[,n]<-NULL
  dataframe<-dataframe[dataframe[,classifier] == maiority,]
  dataframe<-rbind(dataframe,dataframe_minority)
  dataframe<-dataframe[sample(nrow(dataframe)),]
  return(dataframe)
}

randomUndersampling <- function(dataframe, classifier){
  if(class(dataframe[,classifier])!="factor"){
    print("seu classificador nao deve ser numerico!!!")
    nrow(null)
  }
  temp <- summary(dataframe[,classifier])
  temp <- data.frame(temp)
  if(nrow(temp)!=2){
    print("seu classificador tem mais de 2 classificações!!!")
    nrow(null)
  }
  names <- row.names(temp)
  if(temp[names[1],]>temp[names[2],]){
    minority <- names[2]
    maiority <- names[1]
    dataframe_minority <- dataframe[dataframe[,classifier] == names[2],]
  }else{
    minority <- names[1]
    maiority <- names[2]
    dataframe_minority <- dataframe[dataframe[,classifier] == names[1],]
  }
  
  n<-ncol(dataframe)
  output<-dataframe[,classifier]
  output<-factor(ifelse(dataframe[,classifier] == "NEUTRAL",0,1))
  input<-dataframe
  input[,classifier]<-NULL
  newData<-ubUnder(X= input, Y=output, perc = nrow(dataframe_minority)/(nrow(dataframe)-nrow(dataframe_minority))*100, method = "percUnder", w = NULL)
  dataframe<-cbind(newData$X,newData$Y)
  dataframe[,classifier]=dataframe[,n]
  dataframe[,n]<-NULL
  dataframe<-dataframe[sample(nrow(dataframe)),]
  dataframe[,classifier] <- factor(ifelse(dataframe[,classifier] == 0,"NEUTRAL","VULNERABLE"))
  return(dataframe)
}

exportCrossValidation <- function(modules,metrics,label)
{
  together_v <- NULL
  together_n <- NULL
  for (table in modules){
    
    con <- dbConnect(MySQL(), user = 'root', password = 'admin', host = '127.0.0.1', dbname='software')
    functions_no_vul <- dbGetQuery(con, paste("SELECT * FROM software.FUNCTIONS_neutral_",table,sep = ''))
    functions_no_vul <- subset(functions_no_vul, select = metrics)
    together_n <- rbind(together_n,functions_no_vul)
    dbDisconnect(con)
  }
  
  for (table in modules){
      
    con <- dbConnect(MySQL(), user = 'root', password = 'admin', host = '127.0.0.1', dbname='software')
    
    query_vuln <- paste("SELECT * FROM software.FUNCTIONS_affected_",table,";",sep = "")
    print(query_vuln)
      
    functions_vul <- dbGetQuery(con,query_vuln)
    functions_vul <- subset(functions_vul, select = metrics)
    together_v <- rbind(together_v,functions_vul)
    
    dbDisconnect(con)
      
  }
    
  if(nrow(together_v)<10) return(NULL)#o minimo é o numero de folds, porque ele deve pegar 1 de cada fold

  dados<-rbind(unique(together_v),unique(together_n))
  dados$Affected <- factor(ifelse(dados$Affected == 1,"VULNERABLE","NEUTRAL"))
  
  only_metrics <- dados
  only_metrics$Affected <- NULL
  
  dados <- dados[!duplicated(only_metrics),]
    
  set.seed(1837)
  #embaralhar as colunas da tabela randômicamente com o sample
  dados<-dados[sample(nrow(dados)),]
  
  #normalizar
  #dados = as.vector(scale(dados))
  
  #dividir os 10 folds
  folds <- cut(seq(1,nrow(dados)),breaks=10,labels=FALSE)
  
  output <- NULL;
  for(i in 1:10){
    #Segement your data by fold using the which() function 
    testIndexes <- which(folds==i,arr.ind=TRUE)
    testData <- dados[testIndexes, ]
    trainData <- dados[-testIndexes, ]
    
    #print("random undersampling")
    #testData <- randomUndersampling(testData,"Affected")
    
    testData$Fold <-i
    
    output <- rbind(output,testData)
    
  }
  
  write.csv(output, paste(path,label,"_data.csv",sep = ''), row.names=FALSE)
}

metrics <- c("AltCountLineCode","CountInput","CountLineBlank","CountLineCodeDecl","CountLineComment","CountLinePreprocessor","CountPath","CountStmt","CountStmtEmpty","Cyclomatic","CyclomaticStrict","Knots","MinEssentialKnots","RatioCommentToCode","AltCountLineComment","CountLine","CountLineCode","CountLineCodeExe","CountLineInactive","CountOutput","CountSemicolon","CountStmtDecl","CountStmtExe","CyclomaticModified","Essential","MaxEssentialKnots","MaxNesting","Affected")

modules <- c("glibc")
exportCrossValidation(modules,metrics,"glibc")

modules <- c("httpd")
exportCrossValidation(modules,metrics,"httpd")

modules <- c("xen")
exportCrossValidation(modules,metrics,"xen")

modules <- c("kernel")
exportCrossValidation(modules,metrics,"kernel")

modules <- c("mozilla")
exportCrossValidation(modules,metrics,"mozilla")