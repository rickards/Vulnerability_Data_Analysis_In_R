library(RMySQL)
library(caret)
require(randomForest)
library(ipred)
library(plotrix)
library(dplyr)
#library(doMC)

rfRFE <-  list(summary = defaultSummary,
               fit = function(x, y, first, last, ...){
                 library(randomForest)
                 randomForest(x, y, importance = first, ntree=30, ...)
               },
               pred = function(object, x)  predict(object, x),
               rank = function(object, x, y) {
                 vimp <- varImp(object)
                 #vimp$Overall <- vimp[,1]
                 vimp <- vimp[order(vimp$Overall, decreasing = TRUE),,drop = FALSE]
                 vimp$var <- rownames(vimp)
                 vimp
               }, 
               selectSize = pickSizeBest,
               selectVar = pickVars)

projects<-c('glibc','httpd','xen','derby','tomcat','kernel','mozilla')
projects<-c('glibc','httpd','xen')

path<-"/home/rique/Temp_Results_R/cap6/RFE.R/"
dir.create(path,recursive = TRUE)
setwd(path)

metrics <- c("CountLine","CountLineCodeDecl","CountLineBlank","CountStmt","CountStmtDecl","CyclomaticStrict","MaxNesting","Knots","MaxEssentialKnots","CountPath","RatioCommentToCode","CountInput","CountOutput","Affected")

for(project in projects){
  print(project)
  con <- dbConnect(MySQL(), user = 'root', password = 'admin', host = '127.0.0.1', dbname='software')
  df <- dbGetQuery(con, paste("SELECT * FROM software.FUNCTIONS_neutral_",project,sep = ''))
  df <- rbind(df,dbGetQuery(con, paste("SELECT * FROM software.FUNCTIONS_affected_",project,sep = '')))
  df <- subset(df, select = metrics)
  only_metrics <- df
  only_metrics$Affected <- NULL
  df <- df[!duplicated(only_metrics),]
  rm(only_metrics)
  gc()
  dbDisconnect(con)
  
  #RFE
  #df$Affected <- factor(ifelse(df$Affected == 0,"NEUTRAL","VULNERABLE"))
  # define the control using a random forest selection function
  control <- rfeControl(functions=rfRFE, method="cv", number=10, verbose = TRUE, repeats = 10)
  # run the RFE algorithm
  results <- rfe(df[,-14], df[,14], sizes=c(1:13), rfeControl=control)
  # summarize the results
  print(results)
  # list the chosen features
  bestMetrics <- predictors(results)
  write(bestMetrics, paste(path,"bestMetrics_",project,".txt",sep = ''))
  # plot the results
  pdf(paste(path,"rfe_",project,".pdf",sep = ''))
  plot(results, type=c("g", "o"), xlab="Variáveis", metric = results$metric[1])
  dev.off()
  print("DONE!")
}

# SABER O NUMERO MINIMO DE ARVORES PARA EVITAR O MAIOR ERRO POSSÍVEL
#cross.self.rf <- randomForest(Affected~., data=df, ntree = 15, importance = T)
#pdf(paste(path,"number_tree_all_projects",".pdf",sep = ''))
#plot(cross.self.rf)
#dev.off()
#importance <- varImp(cross.self.rf)
#write.csv(importance, paste(path,"importance_all_projects",".csv",sep = ''))


# IMPORTANCIA DE TODAS AS MÉTRICAS
#fit=randomForest(Affected~., data=df, ntree=10, importance=TRUE)
#importance <- varImp(fit)
#write.csv(importance, paste(path,"importance_all_projects",".csv",sep = ''))

#pdf(paste(path,"importance_all_projects",".pdf",sep = ''))
#varImpPlot(cross.self.rf)
#dev.off()

#registerDoMC(cores = 4)


