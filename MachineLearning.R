library(RMySQL)
library(plotrix)
library(unbalanced)
library(DMwR)
library(dplyr)
library(e1071)
library(randomForest)
library(foreign)
library(VGAM)
options(java.parameters = "-Xmx16g")
library(RWeka)
library(caret)

path<-"/home/rique/Temp_Results_R/"
dir.create(path,recursive = TRUE)
setwd(path)

stratified <- function(df, group, size, select = NULL, 
                       replace = FALSE, bothSets = FALSE) {
  if (is.null(select)) {
    df <- df
  } else {
    if (is.null(names(select))) stop("'select' must be a named list")
    if (!all(names(select) %in% names(df)))
      stop("Please verify your 'select' argument")
    temp <- sapply(names(select),
                   function(x) df[[x]] %in% select[[x]])
    df <- df[rowSums(temp) == length(select), ]
  }
  df.interaction <- interaction(df[group], drop = TRUE)
  df.table <- table(df.interaction)
  df.split <- split(df, df.interaction)
  if (length(size) > 1) {
    if (length(size) != length(df.split))
      stop("Number of groups is ", length(df.split),
           " but number of sizes supplied is ", length(size))
    if (is.null(names(size))) {
      n <- setNames(size, names(df.split))
      message(sQuote("size"), " vector entered as:\n\nsize = structure(c(",
              paste(n, collapse = ", "), "),\n.Names = c(",
              paste(shQuote(names(n)), collapse = ", "), ")) \n\n")
    } else {
      ifelse(all(names(size) %in% names(df.split)),
             n <- size[names(df.split)],
             stop("Named vector supplied with names ",
                  paste(names(size), collapse = ", "),
                  "\n but the names for the group levels are ",
                  paste(names(df.split), collapse = ", ")))
    }
  } else if (size < 1) {
    n <- round(df.table * size, digits = 0)
  } else if (size >= 1) {
    if (all(df.table >= size) || isTRUE(replace)) {
      n <- setNames(rep(size, length.out = length(df.split)),
                    names(df.split))
    } else {
      message(
        "Some groups\n---",
        paste(names(df.table[df.table < size]), collapse = ", "),
        "---\ncontain fewer observations",
        " than desired number of samples.\n",
        "All observations have been returned from those groups.")
      n <- c(sapply(df.table[df.table >= size], function(x) x = size),
             df.table[df.table < size])
    }
  }
  temp <- lapply(
    names(df.split),
    function(x) df.split[[x]][sample(df.table[x],
                                     n[x], replace = replace), ])
  set1 <- do.call("rbind", temp)
  
  if (isTRUE(bothSets)) {
    set2 <- df[!rownames(df) %in% rownames(set1), ]
    list(SET1 = set1, SET2 = set2)
  } else {
    set1
  }
}

stratified_less <- function(dataframe, classifier){
  if(class(dataframe[,classifier])!="factor"){
    print("seu classificador nao deve ser numerico!!!")
    nrow(null)
  }
  temp <- summary(dataframe[,classifier])
  temp <- data.frame(temp)
  if(nrow(temp)!=2){
    print("seu classificador tem mais de 2 classificações!!!")
    nrow(null)
  }
  names <- row.names(temp)
  if(temp[names[1],]>temp[names[2],]){
    minority <- names[2]
    maiority <- names[1]
    dataframe_minority <- dataframe[dataframe[,classifier] == names[2],]
    dataframe <- dataframe[dataframe[,classifier] == names[1],]
  }else{
    minority <- names[1]
    maiority <- names[2]
    dataframe_minority <- dataframe[dataframe[,classifier] == names[1],]
    dataframe <- dataframe[dataframe[,classifier] == names[2],]
  }
  
  # Prepare Data
  dataframe[,classifier] <- NULL
  scale_data <- na.omit(dataframe) # listwise deletion of missing
  scale_data <- scale(dataframe) # standardize variables 
  
  n_folds <- nrow(dataframe_minority)
  
  # K-Means Cluster Analysis
  fit <- kmeans(scale_data, n_folds) # 5 cluster solution
  # get cluster means
  aggregate(scale_data,by=list(fit$cluster),FUN=mean)
  # append cluster assignment
  dataframe <- data.frame(dataframe, fit$cluster)
  
  dataframe <- stratified(dataframe,"fit.cluster", 1)
  
  dataframe[,"fit.cluster"] <- NULL
  dataframe$Patched <- maiority
  dataframe<-rbind(dataframe,dataframe_minority)
  dataframe<-dataframe[sample(nrow(dataframe)),]
  return(dataframe)
}

smote_less <- function(dataframe, classifier){
  if(class(dataframe[,classifier])!="factor"){
    print("seu classificador nao deve ser numerico!!!")
    nrow(null)
  }
  temp <- summary(dataframe[,classifier])
  temp <- data.frame(temp)
  if(nrow(temp)!=2){
    print("seu classificador tem mais de 2 classificações!!!")
    nrow(null)
  }
  names <- row.names(temp)
  if(temp[names[1],]>temp[names[2],]){
    minority <- names[2]
    maiority <- names[1]
    dataframe_minority <- dataframe[dataframe[,classifier] == names[2],]
  }else{
    minority <- names[1]
    maiority <- names[2]
    dataframe_minority <- dataframe[dataframe[,classifier] == names[1],]
  }
  
  n<-ncol(dataframe)
  output<-dataframe[,classifier]
  input<-dataframe
  input[,classifier]<-NULL
  newData<-ubBalance(X= input, Y=output, type="ubSMOTE", k=1, positive = minority, percUnder = 200, percOver = 50)
  dataframe<-cbind(newData$X,newData$Y)
  dataframe[,classifier]=dataframe[,n]
  dataframe[,n]<-NULL
  dataframe<-dataframe[dataframe[,classifier] == maiority,]
  dataframe<-rbind(dataframe,dataframe_minority)
  dataframe<-dataframe[sample(nrow(dataframe)),]
  return(dataframe)
}

randomUndersampling <- function(dataframe, classifier){
  if(class(dataframe[,classifier])!="factor"){
    print("seu classificador nao deve ser numerico!!!")
    nrow(null)
  }
  temp <- summary(dataframe[,classifier])
  temp <- data.frame(temp)
  if(nrow(temp)!=2){
    print("seu classificador tem mais de 2 classificações!!!")
    nrow(null)
  }
  names <- row.names(temp)
  if(temp[names[1],]>temp[names[2],]){
    minority <- names[2]
    maiority <- names[1]
    dataframe_minority <- dataframe[dataframe[,classifier] == names[2],]
  }else{
    minority <- names[1]
    maiority <- names[2]
    dataframe_minority <- dataframe[dataframe[,classifier] == names[1],]
  }
  
  n<-ncol(dataframe)
  output<-dataframe[,classifier]
  output<-factor(ifelse(dataframe$Patched == "NEUTRAL",0,1))
  input<-dataframe
  input[,classifier]<-NULL
  newData<-ubUnder(X= input, Y=output, perc = nrow(dataframe_minority)/(nrow(dataframe)-nrow(dataframe_minority))*100, method = "percUnder", w = NULL)
  dataframe<-cbind(newData$X,newData$Y)
  dataframe[,classifier]=dataframe[,n]
  dataframe[,n]<-NULL
  dataframe<-dataframe[sample(nrow(dataframe)),]
  dataframe$Patched <- factor(ifelse(dataframe$Patched == 0,"NEUTRAL","VULNERABLE"))
  return(dataframe)
}

my_predict <- function(model, data4test, name_column4classifier){
  prediction = predict(model, data4test)
  matrix_output <- as.data.frame.matrix(table(prediction,data4test[,name_column4classifier]))
  line <- data.frame(vulnerable=matrix_output[1,2]+matrix_output[2,2],
                     neutral=matrix_output[1,1]+matrix_output[2,1],
                     tp=matrix_output["VULNERABLE","VULNERABLE"],
                     fn=matrix_output["NEUTRAL","VULNERABLE"],
                     tn=matrix_output["NEUTRAL","NEUTRAL"],
                     fp=matrix_output["VULNERABLE","NEUTRAL"])
  return(line)
}

removeHighlyCorrelated <- function(dataframe, classifier){
  dados <- dataframe
  dados[,classifier] <- NULL
  correlationMatrix <- cor(dados[,1:ncol(dados)])
  highlyCorrelated <- findCorrelation(correlationMatrix, cutoff=0.9)
  dados = subset(dataframe, select = -c(highlyCorrelated))
  return(dados)
}

selectAttributeForImpotance <- function(dataframe, classifier, num){
  control <- trainControl(method="repeatedcv", number=10, repeats=3)
  model <- train(Patched~., data=dataframe, method="lvq", preProcess="scale", trControl=control)
  importance <- varImp(model, scale=FALSE)
  ordenado <- importance$importance
  ordenado <- ordenado[order(ordenado[,1],decreasing=TRUE),]
  ordenado <- ordenado[1:num,]
  dataframe <- dataframe[,c(row.names(ordenado),classifier)]
  return(dataframe)
}

funcao <- function(modules,metrics,vulnerabilities,name)
{
  together_v <- NULL
  together_n <- NULL
  for (table in modules){
    
    query_no_vul<- paste("SELECT * FROM ",table," f2s WHERE f2s.Patched=0 and f2s.Occurrence='before' and f2s.ID_Function NOT IN (SELECT distinct tb.ID_Function FROM ",table," tb, (SELECT * FROM ",table," WHERE patched=1 AND Occurrence='before') vul WHERE tb.FilePath=vul.FilePath AND tb.NameMethod=vul.NameMethod",sep = "")
    for (piece in metrics) {
      query_no_vul <- paste(query_no_vul," AND tb.",piece,"=vul.",piece,sep = "")
    }
    query_no_vul <- paste(query_no_vul,");",sep="")
    
    con <- dbConnect(MySQL(), user = 'root', password = 'admin', host = '127.0.0.1', dbname='software')
    functions_no_vul <- dbGetQuery(con,query_no_vul)
    functions_no_vul <- subset(functions_no_vul, select = metrics)
    together_n <- rbind(together_n,functions_no_vul)
    dbDisconnect(con)
  }
  
  
  for (vulnerability in vulnerabilities){
    
    for (table in modules){
      
      query_vul <- "SELECT DISTINCT tb.FilePath,tb.NameMethod"
      for (piece in metrics) {
        query_vul <- paste(query_vul,",tb.",piece,sep = "")
      }
      query_vul <- paste(query_vul,",tb.Patched FROM ",table," as tb, software.PATCHES AS p, software.VULNERABILITIES AS v where tb.Patched=1 and tb.Occurrence='before' and p.P_ID=tb.P_ID AND p.V_ID=v.V_ID AND v.V_CLASSIFICATION LIKE '%",vulnerability,"%';",sep = "")
      
      con <- dbConnect(MySQL(), user = 'root', password = 'admin', host = '127.0.0.1', dbname='software')
      functions_vul <- dbGetQuery(con,query_vul)
      functions_vul <- subset(functions_vul, select = metrics)
      together_v <- rbind(together_v,functions_vul)
      dbDisconnect(con)
      
    }
    
    if(nrow(together_v)<10) return(NULL)#o minimo é o numero de folds, porque ele deve pegar 1 de cada fold
    
    dados<-rbind(together_v,together_n)
    dados$Patched <- factor(ifelse(dados$Patched == 0,"NEUTRAL","VULNERABLE"))
    
    set.seed(1)
    #embaralhar as colunas da tabela randômicamente com o sample
    dados<-dados[sample(nrow(dados)),]
    
    #dividir os 10 folds
    folds <- cut(seq(1,nrow(dados)),breaks=10,labels=FALSE)
    
    #######################################################################################################################
    
    output<-data.frame(vulnerable=0,neutral=0,tp=0,fn=0,tn=0,fp=0)
    for(i in 2:21){
      output[i,]<-data.frame(vulnerable=0,neutral=0,tp=0,fn=0,tn=0,fp=0)
    }
    for(i in 1:10){
      #Segement your data by fold using the which() function 
      testIndexes <- which(folds==i,arr.ind=TRUE)
      testData <- dados[testIndexes, ]
      trainData <- dados[-testIndexes, ]
      
      #data balancing
      trainData_smote <- smote_less(trainData,"Patched")
      trainData_stratified <- stratified_less(trainData,"Patched")
      trainData_randomUnder <- randomUndersampling(trainData,"Patched")
      
      #select attribute
      #trainData_smote <- removeHighlyCorrelated(trainData_smote,"Patched")
      #trainData_stratified <- removeHighlyCorrelated(trainData_stratified,"Patched")
      #trainData_randomUnder <- removeHighlyCorrelated(trainData_randomUnder,"Patched")
      
      #trainData_smote <- selectAttributeForImpotance(trainData_smote,"Patched",5)
      #trainData_stratified <- selectAttributeForImpotance(trainData_stratified,"Patched",5)
      #trainData_randomUnder <- selectAttributeForImpotance(trainData_randomUnder,"Patched",5)
      
      nb_smote = naiveBayes(as.factor(Patched) ~ ., data = trainData_smote)
      output[1,] <- output[1,]+my_predict(nb_smote,testData,"Patched")
      
      nb_stratified = naiveBayes(as.factor(Patched) ~ ., data = trainData_stratified)
      output[2,] <- output[2,]+my_predict(nb_stratified,testData,"Patched")
      
      nb_randomUnder = naiveBayes(as.factor(Patched) ~ ., data = trainData_randomUnder)
      output[3,] <- output[3,]+my_predict(nb_randomUnder,testData,"Patched")
      
      forest_smote = randomForest(as.factor(Patched) ~ ., data = trainData_smote, importance=TRUE, ntree=100)
      output[4,] <- output[4,]+my_predict(forest_smote,testData,"Patched")
      
      forest_stratified = randomForest(as.factor(Patched) ~ ., data = trainData_stratified, importance=TRUE, ntree=100)
      output[5,] <- output[5,]+my_predict(forest_stratified,testData,"Patched")
      
      forest_randomUnder = randomForest(as.factor(Patched) ~ ., data = trainData_randomUnder, importance=TRUE, ntree=100)
      output[6,] <- output[6,]+my_predict(forest_randomUnder,testData,"Patched")
      
      j48Pruned_smote = J48(as.factor(Patched) ~ ., data= trainData_smote, control= c("-C", "0.25", "-M", "2"))
      output[7,] <- output[7,]+my_predict(j48Pruned_smote,testData,"Patched")
      
      j48Pruned_stratified = J48(as.factor(Patched) ~ ., data= trainData_stratified, control= c("-C", "0.25", "-M", "2"))
      output[8,] <- output[8,]+my_predict(j48Pruned_stratified,testData,"Patched")
      
      j48Pruned_randomUnder = J48(as.factor(Patched) ~ ., data= trainData_randomUnder, control= c("-C", "0.25", "-M", "2"))
      output[9,] <- output[9,]+my_predict(j48Pruned_randomUnder,testData,"Patched")
      
      j48Unpruned_smote = J48(as.factor(Patched) ~ ., data= trainData_smote, control= c("-U", "-M", "2"))
      output[10,] <- output[10,]+my_predict(j48Unpruned_smote,testData,"Patched")
      
      j48Unpruned_stratified = J48(as.factor(Patched) ~ ., data= trainData_stratified, control= c("-U", "-M", "2"))
      output[11,] <- output[11,]+my_predict(j48Unpruned_stratified,testData,"Patched")
      
      j48Unpruned_randomUnder = J48(as.factor(Patched) ~ ., data= trainData_randomUnder, control= c("-U", "-M", "2"))
      output[12,] <- output[12,]+my_predict(j48Unpruned_randomUnder,testData,"Patched")
      
      j48ReduceError_smote = J48(as.factor(Patched) ~ ., data= trainData_smote, control= c("-R", "-N", "3", "-Q", "1", "-M", "2"))
      output[13,] <- output[13,]+my_predict(j48ReduceError_smote,testData,"Patched")
      
      j48ReduceError_stratified = J48(as.factor(Patched) ~ ., data= trainData_stratified, control= c("-R", "-N", "3", "-Q", "1", "-M", "2"))
      output[14,] <- output[14,]+my_predict(j48ReduceError_stratified,testData,"Patched")
      
      j48ReduceError_randomUnder = J48(as.factor(Patched) ~ ., data= trainData_randomUnder, control= c("-R", "-N", "3", "-Q", "1", "-M", "2"))
      output[15,] <- output[15,]+my_predict(j48ReduceError_randomUnder,testData,"Patched")
      
      jrip_smote <- train(as.factor(Patched) ~ ., trainData_smote, method = "JRip")
      output[16,] <- output[16,]+my_predict(jrip_smote,testData,"Patched")
      
      jrip_stratified <- train(as.factor(Patched) ~ ., trainData_stratified, method = "JRip")
      output[17,] <- output[17,]+my_predict(jrip_stratified,testData,"Patched")
      
      jrip_randomUnder <- train(as.factor(Patched) ~ ., trainData_randomUnder, method = "JRip")
      output[18,] <- output[18,]+my_predict(jrip_randomUnder,testData,"Patched")
      
      cSVMRadial_smote <- svm(as.factor(Patched) ~ ., data=trainData_smote, kernel="radial", scale = FALSE, type = "C-classification")
      output[19,] <- output[19,]+my_predict(cSVMRadial_smote,testData,"Patched")
      
      cSVMRadial_stratified <- svm(as.factor(Patched) ~ ., data=trainData_stratified, kernel="radial", scale = FALSE, type = "C-classification")
      output[20,] <- output[20,]+my_predict(cSVMRadial_stratified,testData,"Patched")
      
      cSVMRadial_randomUnder <- svm(as.factor(Patched) ~ ., data=trainData_randomUnder, kernel="radial", scale = FALSE, type = "C-classification")
      output[21,] <- output[21,]+my_predict(cSVMRadial_randomUnder,testData,"Patched")
      
      print(i)
    }
    
    output$model <- "model"
    output$balancing <- "balancing"
    
    output[1,"model"] <- "naiveBayes"
    output[2,"model"] <- "naiveBayes"
    output[3,"model"] <- "naiveBayes"
    output[4,"model"] <- "randomForest"
    output[5,"model"] <- "randomForest"
    output[6,"model"] <- "randomForest"
    output[7,"model"] <- "j48Pruned"
    output[8,"model"] <- "j48Pruned"
    output[9,"model"] <- "j48Pruned"
    output[10,"model"] <- "j48Unpruned"
    output[11,"model"] <- "j48Unpruned"
    output[12,"model"] <- "j48Unpruned"
    output[13,"model"] <- "j48ReduceError"
    output[14,"model"] <- "j48ReduceError"
    output[15,"model"] <- "j48ReduceError"
    output[16,"model"] <- "jrip"
    output[17,"model"] <- "jrip"
    output[18,"model"] <- "jrip"
    output[19,"model"] <- "svm"
    output[20,"model"] <- "svm"
    output[21,"model"] <- "svm"
    
    output[1,"balancing"] <- "smote"
    output[2,"balancing"] <- "stratified"
    output[3,"balancing"] <- "randomUnder"
    output[4,"balancing"] <- "smote"
    output[5,"balancing"] <- "stratified"
    output[6,"balancing"] <- "randomUnder"
    output[7,"balancing"] <- "smote"
    output[8,"balancing"] <- "stratified"
    output[9,"balancing"] <- "randomUnder"
    output[10,"balancing"] <- "smote"
    output[11,"balancing"] <- "stratified"
    output[12,"balancing"] <- "randomUnder"
    output[13,"balancing"] <- "smote"
    output[14,"balancing"] <- "stratified"
    output[15,"balancing"] <- "randomUnder"
    output[16,"balancing"] <- "smote"
    output[17,"balancing"] <- "stratified"
    output[18,"balancing"] <- "randomUnder"
    output[19,"balancing"] <- "smote"
    output[20,"balancing"] <- "stratified"
    output[21,"balancing"] <- "randomUnder"
    
    output$recall <- output$tp/output$vulnerable
    output$precision <- output$tp/(output$tp+output$fp)
    output$f_measure <- 2*(output$precision*output$recall)/(output$precision+output$recall)
    output$accuracy <- (output$tp+output$tn)/(output$vulnerable+output$neutral)
    output$fp_rate <- output$fp/output$neutral
    output$fn_rate <- output$fn/output$vulnerable
    output$informedness <- output$tp/output$vulnerable+output$tn/output$neutral
    output$markedness <- output$tp/(output$tp+output$fp)-output$fn/(output$fn+output$tn)
    
    write.csv(output, paste(name,vulnerability,"functions",".csv",sep = '_'))
    
  }
  
}

metrics <- c("AltCountLineCode","CountLine","CountLineCode","CountLineCodeExe","CountLineCodeDecl","Cyclomatic","CyclomaticModified","CyclomaticStrict","Knots","Essential","MaxEssentialKnots","MinEssentialKnots","CountPath","AltCountLineComment","CountLineComment","RatioCommentToCode","CountStmt","CountStmtExe","CountStmtDecl","CountStmtEmpty","CountLineBlank","CountLineInactive","CountSemicolon","MaxNesting","CountInput","CountOutput","CountLinePreprocessor","Patched")
#vulnerabilities<-c("","AuthAlgorithms","Bypass","CrossSiteScripting","CSRF","DenialOfService","DirectoryTraversal","Doubt","ExecuteCode","FileInclusion","GainInformation","GainPrivileges","InformationDisclosure","InputHandling","MemoryCorruption","ObtainInformation","Overflow","Phishing","RaceCondition","Spoofing","XMLInjection")
#vulnerabilities<-c("","Bypass","CrossSiteScripting","DenialOfService","ExecuteCode","GainPrivileges","MemoryCorruption","Overflow")
vulnerabilities<-c("")


modules <- c("FUNCTIONS_5_glibc")
funcao(modules,metrics,vulnerabilities,"glibc")

modules <- c("FUNCTIONS_4_apache")
funcao(modules,metrics,vulnerabilities,"httpd")

#modules <- c("FUNCTIONS_3_arch","FUNCTIONS_3_tools","FUNCTIONS_3_xen")
#funcao(modules,metrics,vulnerabilities,"xen")

#modules <- c("FUNCTIONS_2_arch","FUNCTIONS_2_driver_extra","FUNCTIONS_2_fs","FUNCTIONS_2_kernel","FUNCTIONS_2_linux","FUNCTIONS_2_net")
#funcao(modules,metrics,vulnerabilities,"kernel")

#modules <- c("FUNCTIONS_1_dom","FUNCTIONS_1_javascript","FUNCTIONS_1_javascript_extras","FUNCTIONS_1_javascript_xpconnect","FUNCTIONS_1_layout_rendering","FUNCTIONS_1_libraries","FUNCTIONS_1_mozilla","FUNCTIONS_1_network","FUNCTIONS_1_toolkit","FUNCTIONS_1_webpage_structure","FUNCTIONS_1_widget")
#funcao(modules,metrics,vulnerabilities,"mozilla")

#modules <- c("FUNCTIONS_1_dom","FUNCTIONS_1_javascript","FUNCTIONS_1_javascript_extras","FUNCTIONS_1_javascript_xpconnect","FUNCTIONS_1_layout_rendering","FUNCTIONS_1_libraries","FUNCTIONS_1_mozilla","FUNCTIONS_1_network","FUNCTIONS_1_toolkit","FUNCTIONS_1_webpage_structure","FUNCTIONS_1_widget","FUNCTIONS_2_arch","FUNCTIONS_2_driver_extra","FUNCTIONS_2_fs","FUNCTIONS_2_kernel","FUNCTIONS_2_linux","FUNCTIONS_2_net","FUNCTIONS_3_arch","FUNCTIONS_3_tools","FUNCTIONS_3_xen","FUNCTIONS_4_apache","FUNCTIONS_5_glibc")
#funcao(modules,metrics,vulnerabilities,"all")
